#!/usr/bin/env raku
# Copyright (C) 2022 Kay Rhodes (a.k.a masukomi)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# YOUR CONTRIBUTIONS, FINANCIAL, OR CODE, TO MAKING THIS A BETTER TOOL
# ARE GREATLY APPRECIATED. See https://interrupttracker.com



use v6;
use lib 'lib';
use DB::SQLite;
use XDG::GuaranteedResources;
use Listicles;
use Hey::Database;
use Hey::Resourcer;
use Hey::Timer;
use DateTime::Format;
use Definitely;

# alas, these come from Date.pm6 but they're not
# extractable from it :(
constant time_units = <second seconds minute minutes hour hours day days week weeks month months year years>.Array;
constant time_regexp = /^ (\d ** 1..2) [ ":" (\d ** 2) ]?/;
# ex                         04           :   30
#                             4           :   30
#                             4

# hey start @my_proj +tag1 +tag2
# hey start at 4 @my_proj +tag1 +tag2
# hey start at 4:30 @my_proj +tag1 +tag2
# hey start 4 minutes ago @my_proj +tag1 +tag2
# hey start 2 hours ago @my_proj +tag1

#| Start a new timer
multi sub MAIN('start',
		 *@args #= time adjustment, project, & tags
		) {
	my $db = DB::SQLite.new(filename => guarantee-db());
	my $connection = $db.db;
	my $time = DateTime.now();
	my %compiled_args = compile-timer-args(@args);

	if %compiled_args<projects>.elems == 0 {
		die("must specify at least one project to start a timer.");
	}

	if %compiled_args<time_stuff>.elems > 0 {
		$time = adjust-date-time($time, %compiled_args<time_stuff>)
	}

	my $event_hash = create-event($connection, "timer", $time.posix());
	# TODO figure out why i need .Array here
	# it's $["\@foo"] without it and ["\@foo"] with it
    for %compiled_args<projects>.Array -> $project_name {
		my $project_hash = find-or-create-project($project_name, $connection);
		bind-event-project($event_hash<id>, $project_hash<id>, $connection);
		for %compiled_args<tags>.Array -> $tag { # may be empty list
			tag-event($tag, $event_hash<id>, $connection);
		}
	}
	say("Started Timer for "
		~ %compiled_args<projects>.join(", ")
		~ " at "
		~ datestring($time)
	   );

}


# hey stop at 4
# hey stop at 4:30
# hey stop 4 minutes ago
# hey stop 2 hours ago

#| stop an existing timer
multi sub MAIN("stop",
		*@args #= optional time adjustments (e.g. 4 minutes ago)
		) {

	my $db = DB::SQLite.new(filename => guarantee-db());
	my $connection = $db.db;
	my $time = DateTime.now();
	my $id_match =  @args[0].match(/^ (\d+) $/);
	my $simple_relative_time_match = @args.join(" ")
									  .match(/^ \d+ \s+ \w+ \s+ "ago"/);
	# IF we have a realtive time match
	# then the id match is bogus.
	my $id = ($id_match and (! $simple_relative_time_match))
			  ?? $id_match[0].Int
			  !! -1;

	my %compiled_args = compile-timer-args(
		$id == -1 ?? @args !! @args.splice(1)
	);

	if %compiled_args<time_stuff>.elems > 0 {
		$time = adjust-date-time($time, %compiled_args<time_stuff>)
	}
    my $stopped = ($id == -1)
					?? stop-event($time.posix(), $connection)
					!! stop-specific-event($id, $time.posix(), $connection);

	$stopped ?? say("Stopped at " ~ datestring($time))
			 !! say("No timer was running");

}

#| see a log of recent timers
multi sub MAIN("log",
			   Int $number,
			   Str $duration
			  ) {

	if ! time_units.includes($duration) {
		die("You must specify a valid duration");
	}
	if $number < 1 {
		die("You must specify at least 1 unit of duration. E.g. 1 week");
	}

	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	my $connection = $db.db;
	#TODO limit & group by day, or week or whatever
	my $since = DateTime.now();
	if (! ["minute", "minutes", "second", "seconds", "hour", "hours"].include $duration ) {
		# drop it back to midnight
		# because when someone says 1 day ago
		# they don't mean 24hrs from this moment.
		# they mean, all of yesterday.
		$since = $since.earlier(
			hours => $since.hours,
			minutes => $since.minutes,
			seconds => $since.seconds
		)
	}
	$since = $since.earlier([
								   Pair.new($duration, $number)
							   ]);

	my @timers = timers-since($since.posix(), $connection);
	for @timers -> %timer {
		%timer<projects> = timer-projects(%timer, $connection);
		%timer<tags> = timer-tags(%timer, $connection);
	}
	display-timers-as-table(@timers, "All Timers");
}

#| lets you know if there are any timers running & what they are for
multi sub MAIN("running") {
	my $db = DB::SQLite.new(filename => guarantee-db(), :readonly);
	my $connection = $db.db;
	my $timers = current-timers($connection);
	if $timers ~~ Some {
		my $timers_value = $timers.value;
		for $timers_value.Array -> $timer_hash {
			my $projects = timer-projects($timer_hash, $connection);
			my @project_names = $projects.map({$_<name>}).sort;
			@project_names.push("[No Associated Projects]") if @project_names.is-empty;
			say("Timer started at "
			~ datestring(DateTime.new($timer_hash.<started_at>))
			~ " for "
			~ @project_names.sort.join(", "))
		}
	} else {
		say("No timer running.");
	}
}

#-----
# SUPPORT METHODS
sub has-timer-args(@args) returns Bool {
	# 4 minutes ago
	# at 12:30, at 12

	return True if has-ago-timer-args(@args);
	return has-at-timer-args(@args);
}
sub has-ago-timer-args(@args) returns Bool {
	return ! ! (@args.elems > 2
			and @args[2] eq "ago"
			and @args[0].match(/^ \d+ $/)
			and time_units.includes(@args[1])
		   );
}
sub has-at-timer-args(@args) returns Bool {
	return ! ! (@args.elems > 1
		   and @args[0] eq "at"
		   and @args[1].match(time_regexp))
}

sub adjust-date-time(DateTime $dt, @time_stuff) returns DateTime {
	# @time_stuff = [4, "days", "ago"]
	# could add support for "hence" in addition to "ago"... seems silly though.
	return $dt if @time_stuff.is-empty;
	if has-ago-timer-args(@time_stuff) {
		$dt.earlier([Pair.new(@time_stuff[1].lc, @time_stuff[0])])
	} else {
		my $match_data = @time_stuff[1].match(time_regexp);
		my $hour = $match_data[0].Int;
		my $minutes = $match_data.elems > 1
					   ?? $match_data[1].Int
					   !! 0;
		# swap to 24 hour time
		$hour += 12 if $hour < 12;
		my $now = DateTime.now();
		my $then = my $dt = DateTime.new(
			year    => $now.year,
			month   => $now.month,
			day     => $now.day,
			hour    => $hour,
			minute  => $minutes,
		);
		if $hour < $now.hour {
			# i see you left one running from yesterday
			$then = $then.subtract( days => 1 );
		}
		return $then
	}
}

sub extract-time-adjustment-args(@args) returns Array {
	if has-ago-timer-args(@args) {
		return @args[0..2].Array;
	} elsif has-at-timer-args(@args) {
		return @args[0..1].Array;
	}
	return [];

}
sub compile-timer-args(@args) returns Hash {
	my @inner_args = @args;
	my $time_stuff = extract-time-adjustment-args(@args);
	if $time_stuff.elems > 0 {
		@inner_args = @inner_args.splice($time_stuff.elems)
	}

	my $projects = @inner_args.grep({.starts-with('@')}).map({substr($_, 1)});
	my $tags = @inner_args.grep({ $_.starts-with("+") }).map({substr($_, 1)});

	my %compiled_args = (
		"time_stuff" => $time_stuff,
		"projects" => $projects,
		"tags" => $tags
	);
	return %compiled_args;
}


sub guarantee-db() returns Str {
	my $db_path = "data/hey/hey.db";
	my $resource_path = guarantee-resource($db_path, Hey::Resourcer);

	return $resource_path;
}

sub datestring(DateTime $dt) returns Str {
	strftime("%a, %H:%M", $dt);
}
